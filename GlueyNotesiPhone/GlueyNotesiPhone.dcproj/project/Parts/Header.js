/* 
 This file was generated by Dashcode and is covered by the 
 license.txt included in the project.  You may edit this file, 
 however it is recommended to first turn off the Dashcode 
 code generator otherwise the changes will be lost.
 */

// Note: The Header part is considered private and subject to change in future Dashcode releases.
// Note: Properties and methods beginning with underbar ("_") are considered private and subject to change in future Dashcode releases.

function CreateHeader(elementOrID, spec) {
    var headerElement = elementOrID;
    if (elementOrID.nodeType != Node.ELEMENT_NODE) {
        headerElement = document.getElementById(elementOrID);
	}
	
    if (!headerElement.loaded) {
        headerElement.loaded = true;
        var rootTitle = spec.rootTitle || 'Home';
        headerElement.object = new Header(headerElement, spec, rootTitle);
        return headerElement.object;
    }
}

function Header(headerElement, spec, rootTitle)
{
    var styleElement = headerElement;
    // when cloning template, get size from original
    if (spec.originalID) {
        styleElement = document.getElementById(spec.originalID);
    }
    this._headerHeight = dashcode.getElementHeight(styleElement) || 20;
    this._paddingSides = 5;
    this._backButtonLeftPadding = 13;
    this._useTransforms = (window.WebKitCSSMatrix || window.CSSMatrix) ? true : false;
    
    this._inDesign = window.dashcode && window.dashcode.inDesign;
    this.element = headerElement;
    if (!this._inDesign) {
        headerElement.style.overflow = "hidden";
    }
    
    // create elements and add them to the header
    this._topSeparatorElement = this._makeSeparator("TOP");
    this._bottomSeparatorElement = this._makeSeparator("BOTTOM");
    this._title1 = this._makeTitle();
    this._title2 = this._makeTitle();
    this._title1.style.opacity = 0;
    this._title2.style.opacity = 0;
    this._backButton1 = this._makeBackButton();
    this._backButton2 = this._makeBackButton();
    this._backButton1.style.opacity = 0;
    this._backButton2.style.opacity = 0;

    this.element.appendChild(this._topSeparatorElement);
    this.element.appendChild(this._bottomSeparatorElement);
    this.element.appendChild(this._title1);
    this.element.appendChild(this._title2);
    this.element.appendChild(this._backButton1);
    this.element.appendChild(this._backButton2);
        
    // Set up click handler for back buttons
    var self = this;
    var onclickHandler = function (event) {
        self._goBack();
    }
    this._backButton1.onclick = onclickHandler;
    this._backButton2.onclick = onclickHandler;
    
    // Some default parameters for animation, can probably be configured from the Part Spec
    this._animationProperties = '-webkit-transform, opacity';
    this._setAnimationDuration(0.25);
	this._setAnimationTiming('default');
    
    // Init stack and set up root level
    this._stack = [];
    this._goForward(rootTitle, null);
    
    // On orientation change, adjust elements
    window.addEventListener('orientationchange', function() {
        self._sizeChanged();
    }, false);
}

Header.prototype._makeBackButton = function() {
    var newElem = document.createElement("div");
    newElem.style.position = 'absolute';
    newElem.style.top = Math.floor(((this._headerHeight - 30.0) / 2.0)) + 'px';
    newElem.style.width = 'auto';
    newElem.style.height = '30px';
    newElem.style.webkitBorderImage = 'url(Images/BackButton.png) 0 4 0 '+this._backButtonLeftPadding;
    newElem.style.borderWidth = '0px 4px 0px '+this._backButtonLeftPadding+'px';
    
    newElem.style.padding = '0px 4px 0px 0px';
    newElem.style.lineHeight = '30px';
    newElem.style.textAlign = 'left';
    newElem.style.fontSize = '12px';
    
	newElem.style.maxWidth = '20%';
	newElem.style.textOverflow = 'ellipsis';
	newElem.style.whiteSpace = 'nowrap';
	newElem.style.overflow = 'hidden';
    newElem.style.webkitTransform = 'translateX(0)';

    return newElem;
}

Header.prototype._makeTitle = function() {
    var newElem = document.createElement("div");
    var height = this._headerHeight;
    
    newElem.style.position = 'absolute';
    newElem.style.top = 0;
    newElem.style.height = height+'px';
    newElem.style.webkitTransform = 'translateX(0)';

    newElem.style.textAlign = 'center';
    newElem.style.lineHeight = height+'px';
	newElem.style.textOverflow = 'ellipsis';
	newElem.style.whiteSpace = 'nowrap';
	
    // To avoid zero width but having innerHTML div from contributing to extra width
    newElem.style.overflow = 'hidden';

    return newElem;
}

Header.prototype._makeSeparator = function(type) {
    var newElem = document.createElement("div");
    newElem.style.position = 'absolute';
    newElem.style.left = '0px';
    newElem.style.right = '0px';
    newElem.style.width = 'auto';
    newElem.style.height = '1px';
    if (type == "TOP") {
        newElem.style.top = '0px';
        newElem.style.backgroundColor = 'rgba(255, 255, 255, 0.4)';
    } else {
        newElem.style.bottom = '0px';
        newElem.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
    }
    
    return newElem;
}

Header.prototype._disableTransitions = function(elements) {
    for (var i=0; i<elements.length; i++) {
        elements[i].style.webkitTransitionProperty = 'none';
    }
}

Header.prototype._setAnimationDuration = function(duration) {
    this._animationDuration = duration;
    this._animationDurations = duration + "s, " + duration + "s";
}

Header.prototype._setAnimationTiming = function(timing) {	
	this._animationTimings = timing + ', linear';
}

Header.prototype._sizeChanged = function() {
    var headerWidth = this.element.offsetWidth;
    var currentEntry = this._stack[this._stack.length-1];

    // adjust the title position and width
    var currentTitle = currentEntry.titleElement;
    var currentButton = currentEntry.backButtonElement;
    currentTitle.style.width = "";
    var minTitleX = Math.max(currentEntry.backButtonX + currentButton.offsetWidth, 0) + this._paddingSides;
    var titlePosition = this._adjustedTitlePosition(currentTitle, headerWidth, minTitleX);
    this._disableTransitions([currentTitle]);
    if (titlePosition.width != null) {
        currentTitle.style.width = titlePosition.width + "px";
    }
    if (this._useTransforms) {
        currentTitle.style.webkitTransform = 'translateX(' + titlePosition.x + 'px)';
    } else {
        currentTitle.style.left = titlePosition.x + 'px';
    }
    currentEntry.titleX = titlePosition.x;
}

Header.prototype._adjustedTitlePosition = function(title, headerWidth, minTitleX) {
    var result = {};
    // adjust title position and width
    var titleWidth = title.offsetWidth;
    result.x = (headerWidth / 2) - (titleWidth / 2);

    if (minTitleX > result.x) {
        result.x = minTitleX;
        var maxTitleWidth = headerWidth - minTitleX - this._paddingSides;
        if (titleWidth > maxTitleWidth) {
            result.width = maxTitleWidth;
        }
    }
    return result;
}

Header.prototype._performTransition = function(transforms) {
    var total = transforms.length;
    for (var f = 0; f<total; f++) {
        var transform = transforms[f];
        var element = transform.element;

        // enable transitions
        element.style.webkitTransitionProperty = this._animationProperties;
        element.style.webkitTransitionDuration = this._animationDurations;
        element.style.webkitTransitionTimingFunction = this._animationTimings;

        // perform translate transitions
        if (this._useTransforms) {
            element.style.webkitTransform = 'translateX(' + transform.translateX + 'px)';
        } else {
            element.style.left = transform.translateX + 'px';
        }

        // perform opacity and visibility transitions
        if (transform.opacity != null) {
            element.style.opacity = transform.opacity;
        }
        if (transform.visibility != null) {
            setTimeout(function() {
                element.style.visibility = transform.visibility;
            }, this._animationDuration*1000+50);
        }
    }
}

Header.prototype._goForward = function (newTitle, goBackCallback) {
    this._navigate(true, newTitle, goBackCallback);
}

Header.prototype._goBack = function () {
    this._navigate(false);
}

Header.prototype._navigate = function(goFwd, newTitle, goBackCallback) {
    if (!goFwd && this._stack.length < 2) {
        return;
    }

    // cycle the buttons and titles
    var appearTitle, vanishTitle, appearButton, vanishButton;
    if (this._stack.length % 2 == 0) {
        appearTitle = this._title1;
        vanishTitle = this._title2;
        appearButton = this._backButton1;
        vanishButton = this._backButton2;
    } else {
        appearTitle = this._title2;
        vanishTitle = this._title1;
        appearButton = this._backButton2;
        vanishButton = this._backButton1;
    }

    // get current and previous entries
    var backEntry = null, vanishEntry = null, appearEntry = null;
    if (goFwd) {
        if (this._stack.length > 0) {
            backEntry = this._stack[this._stack.length-1];
        }
    } else {
        vanishEntry = this._stack.pop();
        appearEntry = this._stack[this._stack.length-1];
        if (this._stack.length > 1) {
            backEntry = this._stack[this._stack.length-2];
        }
        newTitle = appearEntry.title;
    }
    
    // set labels
    appearButton.innerHTML = backEntry ? backEntry.title : "";
	appearTitle.style.width = '';
    appearTitle.innerHTML = newTitle;

    // gather necessary data
    var headerWidth = this.element.offsetWidth;
    var appearButtonWidth = backEntry ? appearButton.offsetWidth : headerWidth;
    var vanishButtonWidth = backEntry ? vanishButton.offsetWidth : headerWidth;

    // determine appear elements position. prevent overlap title and back button
    var appearButtonX = backEntry ? this._paddingSides : -headerWidth;
    var minAppearTitleX = Math.max(appearButtonX + appearButtonWidth, 0) + this._paddingSides;
    var appearTitlePosition = this._adjustedTitlePosition(appearTitle, headerWidth, minAppearTitleX);
    var appearTitleX = appearTitlePosition.x;
    if (appearTitlePosition.width != null) {
        appearTitle.style.width = appearTitlePosition.width+"px";
    }
    
    // determine vanish elements end position
    var vanishTitleX, vanishButtonX;
    if (goFwd) {
        vanishTitleX = this._paddingSides + this._backButtonLeftPadding;
        if (backEntry) { // never move vanishing title to the right
            vanishTitleX = Math.min(vanishTitleX, backEntry.titleX);
        }
        vanishButtonX = -(vanishButtonWidth + this._paddingSides);
    } else {
        vanishTitleX = headerWidth;
        vanishButtonX = Math.max(this._paddingSides, appearTitleX - this._backButtonLeftPadding);
    }

    // set initial state of buttons and titles
    this._disableTransitions([appearTitle, vanishTitle, appearButton, vanishButton]);
    appearButton.style.opacity = 0;
    appearButton.style.visibility = "visible";
    var appearTitleInitialOpacity = 0;
    var appearButtonInitialX, appearTitleInitialX;
    if (goFwd) {
        if (backEntry) {
            appearButtonInitialX = Math.max(appearButtonX, backEntry.titleX - this._backButtonLeftPadding);
            appearTitleInitialX = headerWidth;
        } else { // if in root state, initial state == end state
            appearTitleInitialX = appearTitleX;
            if (!this._useTransforms) {
                appearTitle.style.left = appearTitleInitialX + 'px';
            }
            appearTitleInitialOpacity = 1;
        }
    } else {
        appearButtonInitialX = -(appearButtonWidth + this._paddingSides);
        appearTitleInitialX = this._paddingSides + this._backButtonLeftPadding
        appearTitleInitialX = Math.min(appearTitleInitialX, appearTitleX); // never move to the left
    }
    appearTitle.style.opacity = appearTitleInitialOpacity;
    appearTitle.style.webkitTransform = 'translateX(' + appearTitleInitialX + 'px)';
    appearButton.style.webkitTransform = 'translateX(' + appearButtonInitialX + 'px)';

    if (this._inDesign) {
        appearTitleX = this._useTransforms ? 0 : this._paddingSides;
        appearTitle.style.left = this._paddingSides+"px";
        appearTitle.style.right = this._paddingSides+"px";
    }    

    // let the transitions engine perform the transition
    var transforms = [
        {element: appearTitle, translateX: appearTitleX, opacity: 1},
        {element: vanishTitle, translateX: vanishTitleX, opacity: 0},
        {element: appearButton, translateX: appearButtonX, opacity: backEntry != null ? 1 : 0},
        {element: vanishButton, translateX: vanishButtonX, opacity: 0, visibility: "hidden"},
    ];
    var self = this;
    Transition._addDelayedTransitionCallback(function() {
        self._performTransition(transforms)
    });

    if (goFwd) {
        // push new state into stack
        var newStackEntry = { 
            title : newTitle, 
            titleX : appearTitleX,
            backButtonX: appearButtonX,
            titleElement: appearTitle,
            backButtonElement: appearButton,
            callback : goBackCallback
        };
        this._stack.push(newStackEntry);
    } else if (vanishEntry.callback) {
        vanishEntry.callback(vanishEntry.title, appearEntry.title);
    }
}
