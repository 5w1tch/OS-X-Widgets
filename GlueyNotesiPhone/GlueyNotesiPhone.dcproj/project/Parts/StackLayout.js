/* 
 This file was generated by Dashcode and is covered by the 
 license.txt included in the project.  You may edit this file, 
 however it is recommended to first turn off the Dashcode 
 code generator otherwise the changes will be lost.
 */

function CreateStackLayout(elementOrID, spec)
{
    var containerElement = elementOrID;
    if (elementOrID.nodeType != Node.ELEMENT_NODE) {
        containerElement = document.getElementById(elementOrID);
    }
	if (!containerElement.loaded) {
		containerElement.loaded = true;
		containerElement.object = new StackLayout(containerElement, spec);
		
		return containerElement.object;
	}
}

function StackLayout(containerElement, spec)
{
    this.element = containerElement;
    
    var subviewsTransitions = spec.subviewsTransitions || [];
    
    this._views = [];
    this._currentView = null;
    this._viewsOldOpacity = {};
    var kids = containerElement.childNodes;
    this._inDesign = window.dashcode && window.dashcode.inDesign;
    var firstElementDone = false;
    for (var i=0; i<kids.length; i++) {
        if (kids[i].nodeType == Node.ELEMENT_NODE) {
            var view = kids[i];
            this._views[this._views.length] = view;
            // Doing this only during runtime since we don't want any of the settings to end up in the files during design time. Also, design time view swapping is done differently.
            if (!this._inDesign) {
                view.style.position = (firstElementDone) ? 'absolute' : 'relative';
                if (view.style.opacity) this._viewsOldOpacity[view] = view.style.opacity;
                view.style.opacity = (firstElementDone) ? 0 : 1;
                firstElementDone = true;
                
                // Make sure that 'display' is set correctly, since we are now using 'opacity' for performance reasons
                view.style.display = 'block';
            }
        }
    }
    
    if (this._views.length > 0) {
        this._viewsTransition = [];
        this.setCurrentView(this._views[0]);
        
        if (this._views.length == subviewsTransitions.length) {
            for (var i=0; i<this._views.length; i++) {
                this._viewsTransition[i] = CreateTransitionWithProperties(subviewsTransitions[i]);
            }
        }
    }
}

StackLayout.prototype.getAllViews = function()
{
    return this._views;
}

StackLayout.prototype.getCurrentView = function()
{
    return this._currentView;
}

StackLayout.prototype.setCurrentView = function(newView, isReverse)
{
    // Look up by id if necessary
    newView = this._getView(newView);
    var oldView = this.getCurrentView();
	
    if (!newView || (oldView == newView)) {
        return;
    }
    
    // Make sure the view is ours
    if (!newView.parentNode == this.element) {
        return;
    }
    
    var transition = this._viewsTransition[this._views.indexOf(newView)];
    if (!transition) transition = new Transition(Transition.NONE_TYPE);
    
    if (oldView) {
        if (isReverse) {
            transition = this._viewsTransition[[this._views.indexOf(oldView)]];
        }
    }
    
    this._setCurrentViewPrimitive(newView, oldView, transition, isReverse);
}

StackLayout.prototype.setCurrentViewWithTransition = function(newView, transition, isReverse)
{
    // Look up by id if necessary
    newView = this._getView(newView);
    if (!newView) {
        return;
    }
    
    // Make sure the view is ours
    if (!newView.parentNode == this.element) {
        return;
    }
    var oldView = this.getCurrentView();
    
    this._setCurrentViewPrimitive(newView, oldView, transition, isReverse);
}

StackLayout.prototype.getTransitionForView = function(view)
{
    // Look up by id if necessary
    view = this._getView(view);
    return this._viewsTransition[[this._views.indexOf(view)]];
}

StackLayout.prototype._getView = function(view)
{
    if (view) {
        if (view.nodeType == Node.ELEMENT_NODE) {
            // Already an element
            return view;
        }
        if (view.element) {
            // It's a part object
            return view.element;
        }
        // Try it as an id
        return document.getElementById(view);
    }
    return null;
}

StackLayout.prototype._setCurrentViewPrimitive = function(newView, oldView, transition, isReverse)
{
    // newView must be the element now and all error checking has been done.
    
    // View swapping in design time is done in application. Also, we want to be very careful about performing transition during design time because the attributes that get added during the transition into the DOM will get persisted into the HTML during regeneration.
    if (!this._inDesign) {
        if (transition) {
            if (oldView) oldView.style.opacity = this._viewsOldOpacity[oldView] ? this._viewsOldOpacity[oldView] : null;
            // I would like to reset the newView.opacity but doing that causes cross-fade not to work...
            if (transition.type != Transition.CROSS_FADE_TYPE) {
                if (newView) newView.style.opacity = this._viewsOldOpacity[newView] ? this._viewsOldOpacity[newView] : null;
            }
            transition.perform(newView, oldView, isReverse);
        }
        else {
            if (oldView) {
                oldView.style.position = 'absolute';
                oldView.style.opacity = 0;
            }
            if (newView) {
                newView.style.position = 'relative';
                newView.style.opacity = this._viewsOldOpacity[newView] ? this._viewsOldOpacity[newView] : null;
            }
        }
    }
    
    this._currentView = newView;
}
